软件操作注意事项:

1. CH341A.EXE 24\25编程器软件中, 检测功能仅属于辅助功能, 由于部份芯片的数据手册找不到,
无法得到对应芯片的标识厂商\芯片ID的信息, 才造成此功能未能完善, 所以有部份芯片是无法检测出的, 
所以说检测功能的准确性也并非百分百.
-----------------------------------------------------------------------------------------------------------------------------
2.有关检测识别错误问题(指MX25L6445识别为MX25L6405之类), 例如MX25L6405和MX25L6406,MX25L6445, 
三个型号的芯片设备号都是相同的, 所以就导至误识别.
-----------------------------------------------------------------------------------------------------------------------------
3. 当检测目标芯片为 "Unknown", 并不代表编程器不能烧写. 只要能检测到芯片ID信息, 都可通过手动选择芯片进行烧写操作.
如芯片列表中没有对应型号, 可直接选择接近的型号\品牌, 即选择相同的容量即可. 95%的芯片编程指令都是一样兼容的.
其中 厂商 一项中有 "COMMON", 代表通用.各种品牌芯片的编程指令都是一样的(SST和ESMT除外). 
所以在软件中型号\品牌只能算得上是一个称呼, 只要选对了芯片容量, 即可直接烧写操作(SST和ESMT除外).
-----------------------------------------------------------------------------------------------------------------------------
4. 如芯片列表中, 没有你所需要的型号时, 可在 厂商 一项选为 COMMON, 然后选择你相应芯片的容量即可.
-----------------------------------------------------------------------------------------------------------------------------
5. 当检测信息内容的最后四行都是显示$FF或$00, 说明芯片引脚未正常与测试座完好接触, 请检查是否放反芯片或虚焊等.
同时也很可能芯片是坏的, 无法读取芯片信息. 少数不常用的特殊芯片是无法检测出来的, 依然是$FF或$00, 
因为不支持读取芯片设备号信息.
-----------------------------------------------------------------------------------------------------------------------------
6. 如碰到使用"自动"按钮烧写芯片时, 出现提示"写操作超时失败!"的错误信息. 这时应改用手动操作, 
点击"擦除"完成后, 需要等上十几秒, 再点击"编程". 
(原因1可能是个别芯片兼容问题, 读写要等待间隔一断时间; 
原因2芯片引脚与编程器测试座接触不好, 编程器未正确连接芯片, 导至芯片无响应电脑发出的指令).
-----------------------------------------------------------------------------------------------------------------------------
7. 在读写操作过程中, 不建议你再进行其它操作(如浏览网页\QQ\下载等), 可能会造成软件停止响应\读写数据失误\数据校验失败.
-----------------------------------------------------------------------------------------------------------------------------
8. 由于SST和ESMT这两种牌子的芯片不支持按页数据写操作, 一次只能传输1个字节, 再加上受限USB协议速度限制, 
所以在编程这两种牌子的芯片的速度是很慢的. (个别用户更认为软件死掉了)
-----------------------------------------------------------------------------------------------------------------------------
9. 烧写AT26系列芯片, 要求在选项里开启 "使用块/扇区擦除模式", 并关闭 "AAI编程模式". 
注: 老版核心的AT26芯片, 可能会出现读写失败等问题; 软件按照新版核心的AT26芯片编程方式, 读写速度与常见25芯片无太大差别.
-----------------------------------------------------------------------------------------------------------------------------
10. 如果擦除不成功, 可以在 "操作选项" 里切换 "使用块/扇区擦除模式" 功能再试.
-----------------------------------------------------------------------------------------------------------------------------
11. 运行软件后, 
   如果出现错误提示 检测到驱动程序未正确安装, 请安装.
   解决方法:
      (一).请确认是否安装好驱动, 到设备管理器查看.
      (二).如果可使用正常烧写芯片, 可忽略此提示.
      (三).如想不再有此提示, 卸载驱动, 重启电脑, 再装过驱动.
      (四).你安装的驱动, 不是用由本人软件包里提供的.
      (五).由于系统UAC没关闭, 没有权限查询驱动状态导致, 可尝试关闭.   (WIN7\WIN8以上用户注意此项)

  如果软件运行无任何反应, 或提示地址异常错误.
  解决方法:
      (一).操作系统问题, 可能你用的是精简版系统, 或有问题的GHO系统,  更换一个安装即可.
      (二).系统安装了安全软件(例如360卫士, 腾讯管家, 金山毒霸等等), 请在安全软件里将编程器软件加入到信任程序列表中即可.
-----------------------------------------------------------------------------------------------------------------------------
12. 如出现卡死现像(即只能检测), 其它任何操作都卡死, 请重装驱动程序或者操作系统吧.
-----------------------------------------------------------------------------------------------------------------------------
13. 如果点击打开\保存按钮出现卡死现像, 到操作选项里,  使用 WINDOWS系统 打开\保存 对话框  打钩 -> 确定, 然后再试.
-----------------------------------------------------------------------------------------------------------------------------
14. 不建议使用USB延长线, 就算要用, 请尽量选短的线, 质量好的线, 否则可能导致检测芯片无法识别或误别错误, 写芯片 校验无法通过等异常.
-----------------------------------------------------------------------------------------------------------------------------
15.需要烧写OTP区域, 请到选项里选择烧写区域. 默认只读\写Main Memory区域.
     OTP区烧写步聚:
     操作选项->25\26芯片->烧录区域 里, 点击 "写入\校验\读取\查空" 按钮(自动按钮均包含以上功能),  会按所选的区域进行操作读写
     Main Memory 只操作这区域数据, Sectured OTP区忽略
     Sectured OTP  只操作这区域数据, Main Memory区忽略
     Main Memory+Sectured OTP,  操作全部区域数据

     放置好支持OTP的芯片, 然后 检测, 识别后, 数据区会显示Sectured OTP区的页面.
           读取: 然后点击读取按钮, 如果芯片里的OTP区含有数据的,  将会显示到Sectured OTP区的页面.
           写入: 然后加载含有OTP数据的完整固件,  然后点击  自动 自动按钮即可. 直到完成.

    注意: 芯片OTP区必须是没用过的,  OTP区是一次性的, 已有数据的为用过的,  不能写, 不能擦.
    烧写完成后, 记得将选项改回Main Memory,   避免以后写芯片 误写 不需要写OTP数据区的芯片.
-----------------------------------------------------------------------------------------------------------------------------
16.网上买的测试夹子连接路由刷机到底能不能用？
看这贴子, 自然明白, 本人不再做解释
http://forum.anywlan.com/thread-279826-1-1.html
凡是试图在线连目标板子编程, 而无法识别的用户, 均不作为编程器\软件问题
当编程器通过夹子连到路由主板上, 那么 编程器的供电同时也供给了路由,  那么路由的CPU也有电了.
这时 FLASH是听CPU的指令呢,  还是听你编程器软件的指令呢, 显然谁的指令都接受不了,打架啦...

当然夹子是好的, 只是路由不支持而已.  是否能用夹子, 取决你设备主板是否支持.
-----------------------------------------------------------------------------------------------------------------------------
17. 刷写电脑主板 提示 (超出范围, 超出部份将被忽略!)的解决方法
官方提供的BIOS文件一般是基于官方软件刷写的,  BIOS文件前面部份或后面部份会附加了一些无用东西, 
所以造成BIOS文件大于所刷写芯片容量, 自然软件会提示超出范围.
拿一个8M芯片为例, W25Q64,  从芯片型号上看, 25代表是25 SPI FLASH类型的储存芯片, 后面表示为64MBit(位)容量
电脑上1Byte字节=8Bit位, 那么64MBit(位)换算为Byte字节, 即64除以8=8MByte字节
右键点击BIOS文件属性. 在大小一栏 所见 8.00 MB (8,388,608 字节),   8M*1024*1024=8388608字节.
如果查看文件显示的文件大小字节数不对,  那么软件自然就会提示超出范围了...
由于不同主板厂家, BIOS文件的数据定义不一定相同的.  可以使用WINHEX等相关软件编辑BIOS文件, 
在文件前面或者后面删除多余的字节数, 保存后分别刷入芯片试机便知.
或者在编程器软件上载入文件时, 在数据载入配置窗口, 在文件起始地址填上要删除前面部份的字节数地址即可.
-----------------------------------------------------------------------------------------------------------------------------
18. 刷写电脑主板BIOS后, MAC地址丢失.
因为官方的提供的BIOS是基于软件升级的, 且BIOS文件不含有MAC地址模块的, 所以用编程器刷写就会出现MAC丢失的情况.
在这种情况下，在系统里可以通过“本地连接属性--配置--高级--network address”，修改MAC地址来实现正常上网，不过重装系统后又要重新设置
当然也有其它方法可以恢复, 可以使用官方的DOS下的刷写程序 修复. 
以下拿2种BIOS为例,其它的BIOS MAC恢复方法, 具体可以网上搜索.
AMI BIOS 
输入AFUDOS /M XXXXXXXXXXXX，其中XXXXXXXXXXXX为主板集成网卡的12位 MAC地址
AWARD BIOS 
输入awdflash XXX.XXX /PY/SN /NVMAC:XXXXXXXXXXXX/WB，前面的 XXXX.XXX代表BIOS文件名称

=========================================================================
FAQ:
什么叫做编程器固件?
编程器固件是对整个FLASH进行全盘拷贝或刷写，其它的如CFE，UBOOT,（只刷特定的区块，就好像是电脑的bios），还有版本升级的固件就像是从XP升到WIN7一样，所以编程器固件就是ghost全盘，cfe,uboot之类就像是电脑的bios,一旦bios损坏无法开机，要么用编程器刷编程器固件（全盘刷写），要么用工具只刷CFE（就像电脑BIOS），然后再装系统。
一个编程器用的固件文件==UBOOT/cfe + kernel + nvram

UBOOT 或 cfe = 相当于电脑主板的 Bios，不同的芯片用不同的文件

kernel = 路由器用的固件，也等于网站下载的固件
        相当于电脑里的 Windows，

nvram = 路由器系统配置文件

这些就是最基本的文件，都在 Flash 里面，组合成一个路由器系统，编程器固件就是把 Flash 里的所有文件整成一个文件.
